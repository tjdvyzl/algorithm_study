# 문제주소

https://www.acmicpc.net/problem/1011

<br><br>

# 문제 접근 방법

<pre>
수학 으로 접근했다.
문제에서 주의할 점은 target이 y가 아니라 y-1이라는 점이다.
이때 y-1까지 도착하는 순간에 2만큼 이동해서 y-1에 도착하거나, 1만큼 이동해서 y-1에 도착하는 것이다. 
  ㄴ y에 도착하는 순간에 1만큼 이동하는 것과 동치이다. 
k만큼 이동했을 때 주어지는 선택지는 k-1, k, k+1이다. 
이 조건을 이용해서 이동 횟수의 최솟값을 구하기 위해 등차수열을 이용했다. 
처음에 출발 할 때 최대한 1씩 증가시키는것이다. 이 지점을 p라고 하자. 
이렇게 되면 y까지의 범위는 최소 p만큼 왔던 거리를 한번 더 갈 수 있다. 
이때 j번 이동했다고 가정하면 y >= j*(j+1)이 된다. 

좌표평면으로 생각해보면 편하다. 
0 ~ y 지점이 있을 때 이 수평선에서 어떤 점들 x1, x2 (x1 < x2), 그리고  
위에서 말했던 p라는 (j * (j + 1) / 2 <= y-1)인 점이 있다고 가정하자. 
그리고 p에서 (y-1) 까지의 거리를 sub라고 하자. 

최대한 1씩 증가시켜서 j번 이동했다고 가정하자. 
이때 최대한으로 취급할 수 있는 범위는 0 ~ j*(j+1)/2 + j + j*(j+1)/2 이다.  
만약 y가 위 범위보다 크다면 j번이 아니라 j+1, j+2, ... , j+A번 이동할 수 있기 때문이다. 

내가 풀어놓고 어떻게 풀었는지 자세히 설명하는게 어렵다..
예를들어 j가 3일 때 1, 2, 3  3  3, 2, 1인 셈이다. 

여기서 구간을 세 구간 나누어서 생각할 수 있다. 
먼저, y-1인 지점까지 1칸 이동, 2칸 이동, 3칸 이동, 2칸 이동으로 이동할 수 있는 경우이다. 
다른 의미로는 p인 지점에서 y-1인 지점까지 최소한의 횟수로 갈 수 있다고 볼 수 있다. 

그리고 y-1인 지점까지 1, 2, 3, 3, 2로 이동할 수 있는 경우이다. 

마지막으로 y-1인 지점까지 1, 2, 3, 3, 3, 2로 이동할 수 있는 경우이다. 


</pre>

<br><br>

# 착각했던 점

<p>

</p>
<p>

</p>
<br><br>

# 코드

<pre>
<code>
#include <iostream>
using namespace std;
#include <cmath>
#include <string.h>
#include <vector>

typedef long long ll;

int tc;

ll x, y;

int main() {
  cin >> tc;
  while (tc--) {
    cin >> x >> y;
    y -= x, x = 0;
    ll j = 0;
    for (; (j + 1) * (j + 1) <= (y - 1) || (j + 1) * (j + 1) <= y; j++) {
    }
    ll sub = (y - 1) - (j * (j + 1) / 2);
    ll x1 = j * (j - 1) / 2;
    ll x2 = j * (j + 1) / 2 - 1;

    if (x1 > sub)
      cout << j + (j - 2) + 1 << "\n";
    else if (x1 <= sub && sub <= x2)
      cout << j + (j - 2) + 2 << "\n";
    else
      cout << j + (j - 2) + 3 << "\n";
  }
}
</code>
</pre>

<br><br>

<p>

</p>
