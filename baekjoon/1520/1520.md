# 문제주소
https://www.acmicpc.net/problem/1520


<br><br>
# 문제 접근 방법
<pre>
dfs + dp로 접근했다.
먼저 값들을 저장할 m, 각 가지로 갈라졌을 때의 경우의 수들을 저장할 dp, 방문처리를 할 v배열을 선언한다.
5 4 3
4 3 2
3 2 1
라는 예시를 들어보자. 좌표의 시작은 (1,1)이고 종점은 (3,3)이다.

(1,2) (1,3) (2,2) (2,3) (3,2) (3,3)으로 가는 경로만 고려해보자. {(1,2) --> (3,3)}

1. (1,3)에서 (3,3)으로 가는 경우의 수 --> 1가지 밖에 없다.

2. (2,2)에서 (3,3)으로 가는 경로를 생각해보자.
    ㄴ(2,3)좌표에서 (3,3) 좌표로 가는 경우의 수는 1가지 밖에 없다.
    ㄴ또한 (3,2)에서 (3,3) 좌표로 가는 경우의 수는 1가지 밖에 없다.
    ㄴ여기서 (2,2)에서는 (2,3), (3,2)의 가지들로 갈라질 수 있는데, (2,3)일 때 1, (3,2)일 때 1이므로
    ㄴ(2,2)에서 (3,3)으로 갈 수 있는 경우의 수는 총 2가지이다.

3. (1,2)에서 (3,3)으로 가는 경로를 생각해보자.
    ㄴ(1,3)에서 (3,3) 좌표로 가는 경우의 수는 1가지 이다.
    ㄴ(2,2)에서 (3,3) 좌표로 가는 경우의 수는 2가지 이다.
    ㄴ여기서 (1,2)에서는 (1,3), (2,2)의 가지들로 갈라질 수 있는데, (1,3)일 때 1, (2,2)일 때 2이므로
    ㄴ(1,2)에서 (3,3)으로 갈 수 있는 경우의 수는 총 3가지이다.

(1,1)에서 오른쪽으로 갈라지는 경우의 수를 보았고, 밑으로 갈라지는 경우의 수도 똑같이 생각해주면 된다.

1. (3,1)에서 (3,3) 좌표로 가는 경우의 수는 1가지 밖에 없다.

2. (2,2)에서 (3,3)으로 가는 경로는 위에서 설명했듯이 총 2가지이다.

3. (2,1)에서 (3,3)으로 가는 경로를 생각해보자.
    ㄴ(3,1)에서 (3,3)으로 가는 경우의 수는 1가지이다.
    ㄴ(2,2)에서 (3,3)으로 가는 경우의 수는 2가지이다.
    ㄴ여기서 (2,1)에서는 (3,1), (2,2)의 가지들로 갈라질 수 있는데 (3,1)일 때 1, (2,2)일 때 2이므로 
    ㄴ(2,1)에서 (3,3)으로 갈 수 있는 경우의 수는 총 3가지이다.

마지막으로 (1,1)에서 갈라질 수 있는 가지는 (1,2)로 갈라지는 경우와 (2,1)로 갈라지는 경우인데 각각 총 경우의 수는 3 3이므로
총 6가지이다.

방문처리는 꼭 해주는 대신, 다음 갈 좌표인 dy dx의 dp값이 0보다 크다면 이미 그 경로를 통해 종점으로 도착할 수 있는 경우의 수가 존재한다는
의미이므로 dp[dy][dx]값을 현재 좌표 dp 값에 더해주고 넘어가면 된다.
</pre>

<br><br>
# 착각했던 점
<p>
dfs를 stack으로 접근해보려고했는데 생소해서 그냥 포기하고 재귀로 구현했다.
</p>
<br><br>


# 코드
<pre>
<code>
#include <iostream>
using namespace std;
#include <vector>
#include <queue>
#include <stack>

#define FIO ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);

int M, N; // 세로 가로

int m[505][505];

int dp[505][505];

bool v[505][505];

int dir_y[4] = {-1, 1, 0, 0};
int dir_x[4] = {0, 0, -1, 1};

bool check(int dy, int dx, int current_value)
{
    if (dy <= 0 || dx <= 0 || dy > M || dx > N)
        return false;
    if (m[dy][dx] >= current_value)
        return false;
    return true;
}

void dfs(int y, int x)
{
    v[y][x] = true;

    if (y == M && x == N)
    {
        dp[y][x]++;
        return;
    }

    for (int dir = 0; dir < 4; dir++)
    {
        int dy = y + dir_y[dir];
        int dx = x + dir_x[dir];

        if (!check(dy, dx, m[y][x]))
            continue;

        if (!v[dy][dx])
            dfs(dy, dx);

        dp[y][x] += dp[dy][dx];
    }
}

int main()
{
    FIO;

    cin >> M >> N;
    for (int y = 1; y <= M; y++)
        for (int x = 1; x <= N; x++)
            cin >> m[y][x];

    dfs(1, 1);

    cout << dp[1][1] << "\n";
}
</code>
</pre>

<br><br>
<p>
</p>