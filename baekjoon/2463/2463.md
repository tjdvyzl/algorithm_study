# 문제주소
https://www.acmicpc.net/problem/2463


<br><br>
# 문제 접근 방법
Cost(u,v) --> u와 v사이의 경로가 있으면 이 그래프에서 u와 v 사이의 경로가 없을 때 까지 최소 가중치 간선을 제거하는데, 이 때 제거된 가중치들의 합
문제에서 주어진 예제 그림을 보고 cost(2,6)일 때를 이해해보자.
일단 2 --> 6 으로 가려고 할 때 갈 수 있는 경로가 (2,3) (4,5) (3,4) (2,6) (3,6) 이렇게 있다. 2에서 6으로 이동하는 과정에서 존재하는 간선들 중,
2 --> 6으로 갈 수 없을때 까지 최소 가중치 간선들을 제거해야 한다. (위에 나열된 경로는 이해하기 쉽도록 가중치들을 오름차순으로 정렬해놓은 것이다)
(2,3) (4,5) (3,4) (2,6) 을 제거하는 순간 2 에서 6으로 가는 경로가 없기에 이 간선들의 가중치들을 모두 합하면 20이 나온다.
또 다른 관점으로 보자면, 연결된 정점들의 집합 안에서 최소 가중치들을 하나하나 빼보자.
1) (2,3) 간선 제거 --> 집합에서 빠지는 정점 X (즉, a라는 정점에서 b라는 정점으로 이동할 때 영향을 끼치지 않는다.) 가중치의 합 : 2
2) (4,5) 간선 제거 --> 1번과 똑같음. 가중치의 합 : 5
3) (3,5) 간선 제거 --> 집합에서 5번 정점이 빠지게 된다. (즉, a(a != 5)라는 정점에서 5번 정점까지 이동할 때 영향을 끼친다.) 가중치의 합 : 9
    ㄴ 이때 연결된 정점들의 집합을 보자. 5번이 빠지게 되면 (1,5) (2,5) (3,5) (4,5) (5,6)으로 갈 수 있는 경우들이 제거된다. 5 x 9 (45)
4) (3,4) 간선 제거 --> 집합에서 4번 정점이 빠지게 된다. (즉, a(a != {4,5})라는 정점에서 4번 정점까지 이동할 때 영향을 끼친다.) 가중치의 합 : 14
    ㄴ 이때 연결된 정점들의 집합을 보자. 4번이 빠지게 되면 (1,4) (2,4) (3,4) (4,6)으로 갈 수 있는 경우들이 제거된다. 4 x 14 (56)
5) (2,6) 간선 제거 --> 집합에서 {1,2} 에서 {3,6} 으로 가는 경우의 수가 제거된다. 가중치의 합 : 20 
    ㄴ 이때 (1,3) (1,6) (2,3) (3,6) 으로 가는 경우들이 제거된다. 4 x 20 (80)
6) (1,2) 간선 제거 --> 연결된 집합 {1,2}  정점 1에서 2로 가는 경우가 제거된다. 가중치의 합 : 30, 1 x 30 (30)
7) (3,6) 간선 제거 --> 연결된 집합 {3,6}  정점 3에서 6으로 가는 경우가 제거된다. 가중치의 합 : 45, 1 x 45 (45)

--> (45 + 56 + 80 + 30 + 45) == 256

위의 과정은 분리집합으로 구현할 수 있다. 크루스칼 알고리즘으로 최소 가중치를 구하는 방법이 있긴하지만, 
위 과정을 역으로 생각하면 시간을 줄일 수 있다.
M개의 a, b, w가 주어질 때 가중치를 내림차순 정렬하고 sum(모든 가중치들의 합)을 구해놓는다.
1) (3,6)을 연결한다 --> 정점 3과 6이 연결되었으므로 부모인 3의 집합의 개수는 2가 된다. 1 x 1 x 45(역으로 생각해보면 모든 간선들이 연결되었을 때 cost(3,6)은 45이다.), 가중치의 합 : 45 - 15
2) (1,2)을 연결한다 --> 정점 1과 2가 연결되었으므로 부모인 1의 집합의 개수는 2가 된다. 1 x 1 x 30, 가중치의 합 : 30 - 10, 
3) (2,6)을 연결한다 --> 집합 {1,2} {3,6}이 연결되었으므로 부모인 1의 집합의 개수는 4가 된다. 20 x 2 x 2, 가중치의 합 : 20 - 6
4) (3,4)을 연결한다 --> 정점 3과 4가 연결되었으므로 부모인 1의 집합의 개수는 5가 된다. 4(연결 되기 전 부모 1의 집합의 개수) x 1 x 14, 가중치의 합 : 14 - 5
5) (3,5)을 연결한다 --> 정점 3과 5가 연결되었으므로 부모인 1의 집합의 개수는 6이 된다. 5 x 1 x 9, 가중치의 합 : 9 - 4
6) (4,5)을 연결한다 --> 4와 5는 이미 한 집합 안에 포함되어있다. 즉, 사이클이 만들어져도 a라는 정점에서 4 또는 5로 가는 경우의 수에 영향을 끼치지 않는다. 가중치의 합 : 5 - 3
7) (2,3)을 연결한다 --> 위와 똑같다. 가중치의 합 : 2 - 2 


<br><br>
# 착각했던 점
<p>
처음에 문제 이해하는게 너무 어려웠다. Cost(2,6)의 의미도 헷갈려서 결국 다른 블로그를 참고해서 풀었다.
</p>
<br><br>


# 코드
<pre>
<code>
#include <iostream>
using namespace std;
#include <vector>
#include <algorithm>

#define FIO ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
#define C 1000000000
typedef long long ll;

class node
{
public:
    int a;
    int b;
    int w;
    node(int a, int b, int w) : a(a), b(b), w(w) {}
};

int parent[100005];

ll v[100005];

int N, M;

ll sum = 0;

ll ans = 0;

vector<node> vec;

bool compare(node a, node b)
{
    return a.w > b.w;
}

int find(int x)
{
    if (parent[x] == x)
        return x;
    return parent[x] = find(parent[x]);
}

void merge(int a, int b, int w)
{
    //cout << a << ", " << b << ", " << sum << ", " << ans << "\n";
    a = find(a);
    b = find(b);
    if (a == b)
    {
        sum -= w;
        return;
    }
    else if (a > b)
    {
        parent[a] = b;
        ans += v[a] * v[b] * sum;
        v[b] += v[a];
    }
    else
    {
        parent[b] = a;
        ans += v[a] * v[b] * sum;
        v[a] += v[b];
    }
    sum -= w;
    ans %= C;
}

int main()
{
    FIO;

    cin >> N >> M;

    for (int i = 1; i <= N; i++)
        parent[i] = i, v[i] = 1;

    for (int i = 0; i < M; i++)
    {
        int a, b, w;
        cin >> a >> b >> w;
        sum += w;
        vec.push_back(node(a, b, w));
    }

    sort(vec.begin(), vec.end(), compare);

    for (auto e : vec)
    {
        merge(e.a, e.b, e.w);
    }

    cout << ans % C << "\n";
}
</code>
</pre>

<br><br>
<p>
분리집합을 역으로 발상해서 해결하는 문제인거같은데 꾸준히 복기 해야겠다.
</p>
