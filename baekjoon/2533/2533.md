# 문제주소

https://www.acmicpc.net/problem/2533

<br><br>

# 문제 접근 방법

<pre>
dfs + dp로 해결했다. 
문제 조건은 이렇다.
얼리어답터 -> 어떤 새로운 아이디어를 먼저 받아들인 사람 
1. 연결된 모든 노드가 얼리어답터라면 해당 노드는 아이디어를 받아들인다. 
2. 가능한 한 얼리어답터의 최소 수를 구하고자 한다. 
3. 사이클이 존재하지 않으므로 트리임이 자명하다. 

역으로 생각해보면 연결된 노드 중에 얼리어답터가 아무도 없다면 해당 노드는 무조건 얼리어답터여야 한다는 것을 알 수 있다. 
트리이기 때문에 dfs를 통해 접근할 수 있다.
문제에선 무방향 그래프를 주었지만 문제에 접근할 땐 1번 노드를 루트로 설정하고 유방향 그래프로 생각하고 풀자. 

조건은 이렇다. 
1. 해당 노드가 얼리어답터가 아니고, 자식 노드들 중 연결된 노드가 하나인 정점이 존재할 때,
   이 경우 해당 자식 노드는 리프 노드임을 알 수 있고, 얼리어답터의 최소 수를 구하기 위해
   리프 노드의 부모 노드를 얼리어답터로 설정하면 리프 노드 또한 얼리어답터로 설정되기 때문에
   부모 노드와 자식 노드 모두 얼리어답터로 할당해주자. 

2. dfs로 탐색하는 과정에서 부모 노드도 얼리어답터가 아니고 자식 노드도 얼리어답터가 아닌 경우,
   에를 들어
   1 -> 2 -> 3 -> 4 -> 5
           ㄴ 6 -> 7 이 경우를 생각해보자.
   1번 조건에 의해 4번 노드와 6번 노드를 얼리어답터로 설정하는 것이 최적이다. 
   2번 노드와 3번 노드 즉, 부모 노드와 자식 노드가 얼리어답터로 설정되지않았는데
   이때 부모 노드를 얼리어답터로 설정해주면 자식 노드 또한 얼리어답터가 되기 때문에 
   해당 자식 노드들까지 올라오는 경로에서 얼리어답터를 설정한 횟수를 dp에 저장하여 
   2번 노드까지 도달할 때 까지 부모 노드들의 dp값들을 갱신해준다. 그리고 
   2번과 3번이 얼리어답터가 아닌 상황에서 2번을 얼리어답터로 설정해주었기 때문에 
   2번 노드의 dp값을 1 더해주면 된다. 
   
   조금 간단하게 생각해보자면, 얼리어답터를 설정한 이후의 노드들은 트리에서 없다고 생각해도 좋다. 
   이렇게 생각하면 6번과 7번, 4번과 5번을 얼리어답터로 설정해주었기 때문에 트리에서 없고, 
   1 -> 2 -> 3 이런식의 트리가 되는데, 이 또한 1번 조건에 의해 2번을 얼리어답터로 설정해준다고 생각하면 
   간단할 것 같다. 
   
</pre>

<br><br>

# 착각했던 점

<p>
</p>
<br><br>

# 코드

<pre>
<code>

</code>
</pre>

<br><br>

<p>
</p>
