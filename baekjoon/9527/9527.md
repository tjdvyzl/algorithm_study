# 문제주소

https://www.acmicpc.net/problem/9527

<br><br>

# 문제 접근 방법

<pre>
무지성 수학으로 접근했다. 규칙성 찾는게 관건이었는데 나는 자릿수의 개수를 기준으로 규칙성을 찾아 해결했다.
  0000  --> 자리수 0개 
  0001  --> 자리수 1개 
  0010  --> 자리수 2개 
  0011  --> 자리수 2개
  0100
  0101
  0110
  0111  --> 자리수 3개 
여기까지만 적고 규칙성을 찾아도 충분할 것 같다. 
맨 왼쪽에 1이 없다고 생각해보자.
자리수 2개같은 경우 전에 있었던 자리수 0개와 자리수 1개가 그대로 들어온다.
자리수 3개같은 경우 전에 있었던 자리수 0개와 자리수 1개와 자리수 2개가 그대로 들어온다. 
이진수이기 때문에 앞으로의 규칙도 쭉 같을 것이다. 
내가 찾은 규칙은 이렇다.
일단 자리수 0개와 자리수 1개의 자리수 개수 인덱스(ex 자리수 1개라면 cnt[1])에 1의 개수를 구해준다.  
그리고 자리수 2개 인덱스 부터 위에서 구했던 규칙성을 이용하여 추가해나가면 된다. 
자리수 2개일땐 0개와 1개 인덱스가 그대로 온다고 했으므로 자리수 2개 인덱스까지의 1의 개수는 
0과 1의 인덱스의 1의 개수 x 2 + 0과 1의 인덱스의 수 개수 이다. 
10^16이면 2^53정도 까지 존재하므로 cnt[53]까지 쭉 채워준다. 

다 채웠다면 179를 구한다고 가정해보자.
0 ~ 179 
(0 ~ 127) + (128 ~ 179) 로 나눌 수 있다. 
  ㄴ 0 ~ 127로 나눈 이유는 수가 128일 때 자리수가 하나 늘어나게 된다. 
  ㄴ 즉, 128 이전 수인 127까지의 1의 개수는 우리가 전에 구했던 cnt[0] + .. + cnt[8]값이 될 것이다. 
128 ~ 179
{128} 0 ~ (179 - 128) --> 0 ~ 51
  ㄴ 왼쪽과 오른쪽을 128로 빼주고 ans에 128만큼 더해준다는 의미이다. 
  ㄴ 이것이 가능한 이유는 위에서 말했듯이 맨 왼쪽에 1을 가리면 그 위에있었던 자리수 개수인덱스들이 모두 온다고 했다. 
  ㄴ 128 ~ 179까지의 2진수 수들의 맨 왼쪽 1을 가리면 0 ~ 51까지의 수들이 존재한다. 
  ㄴ 즉, (179 - 128 + 1)개의 1이 맨 왼쪽에 존재할 것이고 이만큼 더해준 후 범위를 0 ~ 51로 좁혀줄 수 있따. 
0 ~ 51
(0~31) + (32 ~ 51)
  ㄴ 위와 똑같은 방식이다.
32 ~ 51 --> {32} 0 ~ 19
  ㄴ 위와 똑같은 방식이다. 
0 ~ 19
(0~15) + (16~19) 
  ㄴ 위와 똑같은 방식이다. 
16 ~ 19 --> {16} 0 ~ 3
  ㄴ 위와 똑같은 방식이다. 
0 ~ 3
(0 ~ 1) + (2 ~ 3)
  ㄴ 위와 똑같은 방식이다. 
2 ~ 3 --> {2} 0 ~ 1
  ㄴ 위와 똑같은 방식이다. 
0 ~ 1 끝 
이런식으로 구해주면 된다. 
 
</pre>

<br><br>

# 착각했던 점

<p>

</p>
<p>

</p>
<br><br>

# 코드

<pre>
<code>
#include <cmath>
#include <iostream>
using namespace std;

#define MAX 987654321
#define FIO ios_base::sync_with_stdio(0), cin.tie(0);

typedef long long ll;
ll pos_cnt[60] = {1, 1, 2, 4, 8, 16};   // 각 자리수 마다 숫자의 개수
ll cnt[60] = {0, 1, 3, 8, 20, 48, 112}; // 각 자리수 마다 1의 개수
ll sum[60] = {0, 1};
// cnt[i-1] * 2 + cnt[i-1] == cnt[i]

ll A, B;

// 2진수로 표현했을 때 자릿수 리턴
ll getDigit(ll input) {
  if (input == 0)
    return 0;
  return 1 + getDigit(input / 2);
}

ll getSum(ll input) {
  ll res = 0;
  ll bound = 0;
  while (input) {
    if (bound > 0) {
      res += (input - bound) + 1;
      input -= bound;
    }
    ll inputDigit = getDigit(input);
    res += sum[inputDigit - 1];
    bound = (ll)pow(2, inputDigit - 1);
  }
  return res;
}

int main() {
  cin.tie(0);
  ios_base::sync_with_stdio(0);
  cout.tie(0);

  ll s = sum[0] + sum[1];

  for (int i = 2; i <= 53; i++) {
    pos_cnt[i] = pos_cnt[i - 1] * 2;
    cnt[i] = cnt[i - 1] * 2 + pos_cnt[i - 1];
    s += cnt[i];
    sum[i] = s;
  }

  cin >> A >> B;

  cout << getSum(B) - getSum(A - 1) << "\n";
}

</code>
</pre>

<br><br>

<p>

</p>
